// P5.js Code
// Part of this code has been generated by Bing AI 
// The boilerplate code for this project was provided by Jon Froehlich 

let pHtmlMsg;
let serialOptions = { baudRate: 115200 };
let serial;
let currentSerialVal = 0;
let centerX, centerY;
let angle = 0;
let centerHistory = []; // Store previous center positions
let radiusHistory = []; // Store previous radii
let circleRadius = 50; // Initial circle radius (adjust as needed)
let buttonState = 0; // Initialize button state
let changesOccurred = false; // Flag to track changes

function setup() {
  createCanvas(640, 480);
  background(100);

  centerX = width / 2;
  centerY = height / 2;

  serial = new Serial();
  serial.on(SerialEvents.CONNECTION_OPENED, onSerialConnectionOpened);
  serial.on(SerialEvents.DATA_RECEIVED, onSerialDataReceived);
  serial.on(SerialEvents.ERROR_OCCURRED, onSerialErrorOccurred);

  serial.autoConnectAndOpenPreviouslyApprovedPort(serialOptions);

  pHtmlMsg = createP("Click anywhere on this page to open the serial connection dialog");
  pHtmlMsg.style('color', 'deeppink');
}

function draw() {
  background(100);

  circleRadius = currentSerialVal * 100;

  centerX = constrain(centerX, circleRadius, width - circleRadius);
  centerY = constrain(centerY, circleRadius, height - circleRadius);

  if (changesOccurred) {
    // Store the current center position and radius in history
    centerHistory.push({ x: centerX, y: centerY });
    radiusHistory.push(circleRadius);
  }

  for (let i = 0; i < centerHistory.length; i++) {
    const prevCenter = centerHistory[i];
    const prevRadius = radiusHistory[i];
    noFill();
    stroke(255, 50);
    ellipse(prevCenter.x, prevCenter.y, prevRadius * 2);
  }

  if (buttonState === 1) {
    centerX += 1;
    changesOccurred = true;
  } else if (buttonState === 2) {
    centerX -= 1;
    changesOccurred = true;
  } else {
    changesOccurred = false; // No changes occurred
  }

  angle += 0.01;

  // Increase the history size to 200 (adjust as needed)
  if (centerHistory.length > 200) {
    centerHistory.shift();
    radiusHistory.shift();
  }
}

/**
 * Callback function by serial.js when there is an error on web serial
 * 
 * @param {} eventSender 
 */
 function onSerialErrorOccurred(eventSender, error) {
  console.log("onSerialErrorOccurred", error);
  pHtmlMsg.html(error);
}

/**
 * Callback function by serial.js when web serial connection is opened
 * 
 * @param {} eventSender 
 */
function onSerialConnectionOpened(eventSender) {
  console.log("onSerialConnectionOpened");
  pHtmlMsg.html("Serial connection opened successfully");
}

/**
 * Callback function by serial.js when web serial connection is closed
 * 
 * @param {} eventSender 
 */
function onSerialConnectionClosed(eventSender) {
  console.log("onSerialConnectionClosed");
  pHtmlMsg.html("onSerialConnectionClosed");
}

function onSerialDataReceived(eventSender, newData) {
  const data = newData.split(",");
  currentSerialVal = parseFloat(data[0]);
  buttonState = parseInt(data[1]);
}


/**
 * Called automatically by the browser through p5.js when mouse clicked
 */
function mouseClicked() {
  if (!serial.isOpen()) {
    serial.connectAndOpen(null, serialOptions);
  }
}


// Arduino Code


// const int potentiometerPin = A0;
// const int button1Pin = 2;
// const int button2Pin = 3;

// void setup() {
//   Serial.begin(115200);
//   pinMode(potentiometerPin, INPUT);
//   pinMode(button1Pin, INPUT_PULLUP);
//   pinMode(button2Pin, INPUT_PULLUP);
// }

// void loop() {
//   int analogValue = analogRead(potentiometerPin);
//   int button1State = digitalRead(button1Pin);
//   int button2State = digitalRead(button2Pin);

//   float valFrac = analogValue / 1023.0;
//   Serial.print(valFrac, 4);
//   Serial.print(",");
//   Serial.println(button1State | (button2State << 1)); // Combine button states

//   delay(50);
// }

